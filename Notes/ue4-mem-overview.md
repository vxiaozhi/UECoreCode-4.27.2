# UE4 内存管理综述

## UE4中的对象内存管理方式

以下是UE4中常见的几种对象内存管理模式：

- 引用计数（Reference Counting）:

引用计数是一种基本的内存管理策略，它通过跟踪对象的引用数量来决定何时释放内存。当一个对象的引用计数减少到0时，该对象将被销毁。在UE4中，这种机制广泛应用于自动回收不再需要的对象。引用计数的一个主要优点是它可以快速地释放大量小对象，但也可能导致内存碎片化。

- 智能指针（Smart Pointers）:

智能指针是C++11引入的一种新特性，它可以自动管理对象的生命周期。智能指针通过引用计数机制来跟踪对象的所有权，当智能指针超出作用域或重新赋值时，它所指向的对象将被自动销毁。在UE4中，智能指针用于确保资源的安全释放，避免内存泄漏和悬挂指针问题。

- 对象池（Object Pools）:

对象池是一种优化技术，用于管理和重用对象实例。通过预先创建一定数量的对象并存储在池中，可以快速分配和回收对象，避免了频繁的内存分配和释放操作。在UE4中，对象池广泛应用于需要大量相同类型对象的场景，如子弹或敌人实例。对象池的主要优点是提高性能和减少内存碎片化，但需要额外的内存来存储池中的对象。

- 动态生成（Dynamic Generation）:

动态生成是指根据需要在运行时创建对象。与预先创建的对象池不同，动态生成的对象数量是不确定的，并且可以在游戏过程中动态调整。在UE4中，动态生成常用于地形、树木等可变数量的资源。动态生成的一个主要优点是灵活性高，可以根据需要创建任意数量的对象，但可能影响性能和内存管理。

- 延迟销毁（Lazy Deletion）:

延迟销毁是一种优化技术，用于减少不必要的销毁和重建操作。通过延迟销毁，可以在需要时才真正删除对象，而不是立即回收内存。在UE4中，延迟销毁常用于场景中的非活动对象或临时资源。延迟销毁可以减少不必要的内存分配和释放操作，提高性能，但需要谨慎处理对象的生命周期和状态管理。

## UE4中内存管理的一些特点

- UE4 重载每个 class 和全局的 operator new/delete， 因此普通的new操作会调用UE4的内存分配函数.
- 支持多种FMalloc类型， Linux 系统下默认的时 FMallocBinned2。
- UE4 的小内存以内存池为单位进行管理，内存池中还有内存块没释放，整个内存池都不会释放。因此我们会发现：对象释放了，进程内存占用却回不来。
- 大量对象生命周期只有一帧，因此可采用 FMemStackBase（栈式内存分配器）提高性能。
- 内存泄漏问题，可通过 MALLOC_LEAKDETECTION MallocProfiler2 两种方案进行定位。
- 要用NewObject创建UObject对象，因为NewObject帮我们规范UObject的创建过程。
- UObject对象不能直接删除。因为：大部分UObject派生类并没有定义析构函数， 直接delete会在UObjectBase析构函数中报错，UObject的销毁是由垃圾回收机制实现的。
- UE4 垃圾回收算法：标记清扫法。 具体通过函数 CollectGarbage 实现。
- 非 UObject 对象引用的UObject可通过 AddToRoot 或者 继承FGCObject 来实现 GC。
- 对UObject分组管理， 即 对于复合性的逻辑物体，所有子对象状态同步化 ，整体处理可以大幅减少gc需要遍历的对象数量，大幅度提升gc性能。
- 可通过 Low Level Memory Tracker （LLM） 监控特定模块内存的变化。
- 定位lua临时变量的"内存泄漏"， 可通过 创建LLM Tag标记Lua内存。
- Unlua tick代码要尽量避免创建临时变量。因为： 在tick函数中调用会生成大量临时变量，每个临时变量都是一个lua对象，实际内存远远大于对象数据。同时Lua对象需要等待gc时才能回收。


## 参考

- [UE4中的对象内存管理：深入了解几种模式](https://developer.baidu.com/article/details/2924256)
- [UE5内存管理原理](https://mytechplayer.com/archives/ue5%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8E%9F%E7%90%86)
- [万字长文|深入C++内存管理](https://www.eet-china.com/mp/a136012.html)